
## Webサイトからの情報取得
### ログインフォームがあったら
- webappの名前とバージョンが分かれば、デフォルトのユーザーネーム、パスワードを検索して、試す
- SQLインジェクション
	- ' OR 1=1;--
		- select * from users where username='' and password='' OR 1=1;
	- admin' OR 1=1;--
		- select * from users where username='admin' and password='' OR 1=1;
	- 詳しいことは
		- https://scrapbox.io/tadanomemo777/SQL%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3
- パスワードを忘れた場合の機能を使ってユーザーを列挙を行える可能性

## 入力フォームがあった場合
- 数値しか受け付けないはずのフォームに文字列を入れて送信する
### htmlソースでの検索
- コメントの検索
	- 内部IPアドレスやAPIキー、パスワードが見つかることもある
	- 検索ボックスに「```<!--```」を入れて検索
- キーの検索
	- 検索ボックスに以下を入れて検索
	- `key`
	- `keys`
	- `api`
	- `password`
	- `credential`
	-  `<input type="hidden">`
		- 隠しフィールドの値を書き換える
- CMSについての検索
	- CMSが使われていればCMSの脆弱性をつくこともできる
	- 検索ボックスに
		- wordpress
		- drupal
		- joomla
	- を入れて検索
### Burp Suite
- TargetタブのStitemapからも概要がわかる

### `curl`での確認

`md`ファイルなどはブラウザよりも`curl`での確認が見やすい。

```bash
curl -k <URL>
```

- `-k`：エラーを無視するオプション

### Webサイトのヘッダー情報の取得
CMS、JavaScriptライブラリ、ウェブサーバ、バージョン番号、ウェブフレームワークの取得

```bash
sudo whatweb http://<IP>
```


## SSRF : URLを入力して、サーバーがリクエストを送るフォームがある場合
SSRF : Server-Side Request Forgeryの脆弱性がある可能性がある
攻撃者がサーバーに不正なリクエストを送信させ、内部ネットワークや非公開のAPIにアクセスさせる脆弱性
**SSRFの脆弱性があるケースの詳細**
- ユーザーが指定したURLに対して、サーバーがリクエストを送る機能がある
	- 画像のURLプレビュー
		- ユーザーがURLを入力すると、画像を取得して表示
	- webhookの登録
		- ユーザーがwebhookのURLを指定すると、。サーバーがリクエストを送る
	- 外部APIと連携するシステム
- 外部サービスとの通信を行う機能がある
	- PDFの生成機能
	- クラウド関連の操作
		- AWSやGCPのメタデータにアクセスできるの可能性がある

**検証方法**
1. 内部サービスへのアクセスを確認するためにローカルアドレスにリクエスト送る
	burpsuiteでサーバーがリクエストを送っているかを確認する
	基本的なSSRFテスト
	入力フォームやAPIエンドポイントに、以下のURLを試す
```
http://127.0.0.1/
http://localhost/
http://192.168.1.1/
http://10.0.0.1/
http://[::1]/
```
→ 何らかのレスポンスがある場合、内部アクセスが可能な可能性が高い。

管理パネルのチェック
SSRFで管理パネルやアプリケーションにアクセスできるかを調査
```
http://localhost/admin
http://127.0.0.1:8000/
http://127.0.0.1:8080/
http://127.0.0.1:5000/
http://127.0.0.1:9001/ (Supervisor)
```
→ 404以外のレスポンスや特定の管理画面のレスポンスが返ってきたら脆弱性あり。

**Bypass Techniques（フィルタ回避）**
一部のサーバーでは、SSRFを防ぐために「`localhost` へのリクエスト禁止」などの制限がある。
以下の方法でバイパスを試す。
- IPアドレスのエンコード
```
http://2130706433/  # 127.0.0.1 を整数表記
http://0x7F000001/  # 127.0.0.1 を16進数
```
- DNS Rebinding
一部のサーバーでは、外部ドメインから内部へリクエストを送れるようになる。
```
http://attacker-controlled-domain.com/
```
→ DNSリバインディングを利用し、`localhost` へリダイレクト。



# Basic Authentication（ベーシック認証）のブルートフォースによる突破
目的 : Basic Authentication を利用しているウェブサイトに対してブルートフォース攻撃、辞書攻撃を行い、ログイン資格情報を取得する。

Basic Authenticationはこんなやつ↓
![](https://i.imgur.com/VTmAa0S.png)


1. ターゲットにアクセス
	- http://enum.thm/labs/basic_auth/ にアクセスする。
2. Basic Authentication のリクエストを取得
	- ポップアップが表示されるので、適当な ユーザー名とパスワード を入力し、ログインを試みる。
	- Burp Suite を使用して、このリクエストをキャプチャする。
3. Burp Suite の Intruder にリクエストを送信
	- キャプチャしたリクエストを 右クリック → "Send to Intruder" で Intruder に送る。
4. Authorization ヘッダーのデコード
	- "Positions" タブ に移動し、Authorization ヘッダーの base64 エンコードされた認証情報 をデコードする（base64 decode）。
BurpでBase64デコードする手順
![](https://i.imgur.com/x5r1zdu.png)
5. パスワードリストを設定
	- "Payloads" タブ に移動し、"Payload type" を "Simple list" に設定する。
	- 使用するパスワードリストを選択
	- AttackBox の場合:
	- /usr/share/wordlists/SecLists/Passwords/Common-Credentials/500-worst-passwords.txt
6. ペイロードの処理ルールを追加
	1.  ユーザー名とパスワードを一緒に特殊文字で囲む
		- 例えば "admin:123456" の形式にする。
	2. base64 エンコード
		- ユーザー名とパスワードを base64 エンコードし、Authorization ヘッダーに適用。
	3.   "="（イコール）を削除
		- base64 ではパディングに「=」が使用されるため、エンコードから文字「=」（等号）も削除する
		- 「Payload encoding」の中に=を加える
上の設定を全て行ったときの画面
![](https://i.imgur.com/FeAJfXL.png)
7. 攻撃の実行
	- "Positions" タブ に戻り、"Start Attack" をクリック。
8. 成功したレスポンスを確認
	- ステータスコード 200 を確認する。
	- ステータス 200 が返ってきたリクエストの Authorization ヘッダーをデコードすると、正しい資格情報（username:password）が判明する。
ステータスコードが200の、ログインできる認証情報を発見した画面
![](https://i.imgur.com/wmNsU3R.png)

9. 入手した資格情報でログイン
	- 成功したユーザー名とパスワード を使用し、ウェブサイトにログインする。
	- フラグが表示される。


